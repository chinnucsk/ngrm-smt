понятие алгоритм является основным для всей области компьютерного программирования, поэтому начать мы должны с тщательного анализа этого термина.
слово «алгоритм» (algorithm) уже само по себе представляет большой интерес.
на первый взгляд может показаться, будто кто-то собирался написать слово «логарифм», но случайно переставил первые четыре буквы.
этого слова еще не было в издании словаря webster’s new world dictionary, вышедшем в 1957 году.
мы находим там только устаревшую форму «algorism» — старинное слово, которое означает «выполнение арифметических действий с помощью арабских цифр».
в средние века абакисты считали на абаках (счетных досках), а алгоритмики использовали «algorism».
в эпоху возрождения происхождение этого слова оказалось забытым.
одни лингвисты того времени пытались объяснить его значение путем сочетания слов algiros [больной] и arithmas [число],
другие не соглашались с таким толкованием и утверждали, что это слово происходит от «king algor of castile».
наконец историки математики обнаружили истинное происхождение слова «algorism»: оно берет начало от имени автора знаменитого персидского учебника по математике,
abu ’abd allah muhammad ibn musa al-khwarizml (абу абд аллах мухаммед ибн муса аль-хорезми) (ок. 825 г.), означающего буквально «отец абдуллы, мухаммед, сын мусы, уроженец хорезма»*.
аральское море в центральной азии когда-то называлось озером хорезм, и район хорезма (khwarizm) расположен в бассейне реки амударьи южнее этого моря.
аль-хорезми написал знаменитую книгу kitab al-jabr wa’1-muqabala (китаб аль-джебр валь-мукабала «книга о восстановлении и противопоставлении»).
от названия этой книги, которая была посвящена решению линейных и квадратных уравнений, произошло еще одно слово — «алгебра».
[о жизни и научной деятельности аль-хорезми речь идет в работе н. zemanek, lecture notes in computer science 122 (1981), 1-81].
постепенно форма и значение слова algorism исказились; как объясняется в словаре oxford english dictionary, это слово «претерпело множество псевдоэтимологических искажений,
включая последний вариант algorithm, где произошла путаница» с корнем слова греческого происхождения arithmetic.
этот переход от «algorism» к «algorithm» кажется вполне закономерным ввиду того, что происхождение рассматриваемого слова было полностью забыто
в старинном немецком математическом словаре vollstandiges mathematisches lexicon (leipzig, 1747) дается следующее определение слова algorithmus:
«этот термин включает в себя понятие о четырех типах арифметических операций, а именно: о сложении, умножении, вычитании и делении».
латинское выражение algorithmus infinitesimalis в то время использовалось для определения «способов выполнения действий с бесконечно малыми величинами», открытых лейбницем (leibniz)».
к 1950 году слово «алгоритм» чаще всего ассоциировалось с алгоритмом евклида, который представляет собой процесс нахождения {{наибольшего общего делителя}} двух чисел.
этот алгоритм приведен в книге евклида (euclid) начала (книга 7, предложения 1 и 2).
думаю, имеет смысл привести здесь описание этого алгоритма.
разумеется, у евклида этот алгоритм сформулирован не совсем так.
приведенная выше формулировка иллюстрирует стиль, в котором алгоритмы будут представлены на протяжении всей этой книги.
каждому рассматриваемому алгоритму присваивается идентифицирующая буква (в предыдущем примере использовалась буква е),
а шагам алгоритма — эта же буква в сочетании с числом (el, е2, ез).
главы книги подразделяются на пронумерованные разделы; внутри раздела алгоритмы обозначаются только буквами.
но когда на эти алгоритмы делаются ссылки из других разделов, то к букве присоединяется номер соответствующего раздела.
например, сейчас мы находимся в разделе 1.1; внутри этого раздела алгоритм евклида называется «алгоритм е»,
но ссылаться на него в последующих разделах мы будем как на алгоритм 1.1е.
в качестве примера использования {{дважды связанных списков}} рассмотрим программу дискретного моделирования.
"дискретное моделирование" означает моделирование системы, в которой предполагается, что все изменения состояния системы происходят в некоторые дискретно заданные моменты.
моделируемая "система" обычно представляет собой набор отдельных действующих лиц, которые, хотя и могут взаимодействовать друг с другом, в основном, ведут себя независимо.
например, это могут быть покупатели в магазине, корабли в гавани, сотрудники  некоторого предприятия.
при этом процесс моделирования заключается в выполнении определенных действий, предусмотренных для данного момента,
для перехода к следующему моменту с дальнейшим выполнением других действий, запланированных для нового момента.
И наоборот, "непрерывное моделирование" означает моделирование действий, которые происходят непрерывно,
например движение автомобилей по автостраде, полеты космических кораблей к другим планетам и т. д.
{{Непрерывное моделирование}} часто можно вполне удовлетворительно {{имитировать}} с помощью дискретного моделирования с очень малыми временными интервалами между соседними шагами.
Но в таком случае получится "синхронное" дискретное моделирование, при котором многие части системы слегка изменяются на каждом дискретном временном  интервале, 
и такое приложение обычно нуждается в организации программы несколько иного типа, чем тот, который рассмотрен здесь.
приведенная ниже программа моделирует работу лифта в здании факультета математики калифорнийского технологического института.
результаты такого моделирования, вероятно, будут полезны только тем, кому часто приходится посещать калтех.
и даже им, видимо, проще будет всего несколько раз  воспользоваться этим лифтом, чем создавать специальную программу.
но, как обычно случается при изучении {{методов моделирования}}, используемые методы программирования гораздо интереснее, чем результаты выполнения программ.
рассматриваемые ниже методы иллюстрируют типичные методики, которые используются в программах {{дискретного моделирования}}.
здание факультета математики имеет пять этажей: подвальный, цокольный, первый, второй и третий.
в нем находится один лифт с автоматическим  управлением, который может останавливаться на каждом этаже.
для удобства перенумеруем этажи в следующем порядке: 0, 1, 2, 3 и 4
на каждом этаже есть две кнопки вызова лифта: одна — для движения вверх, а другая — для движения вниз.
на самом деле на этаже 0 имеется  только кнопка up, а на этаже 4 — только кнопка down,
но эти особые случаи будут игнорироваться, потому что дополнительные кнопки никогда не будут использоваться
соответственно эти кнопки будут обозначаться десятью переменными callup[j] и calldown[j], 0 <= j <= 4.
кроме того, переменные callcar[j], 0 <= j <= 4, будут представлять кнопки внутри кабины лифта, которые обозначают этаж назначения.
при нажатии кнопки соответствующей переменной присваивается значение 1,
а после выполнения запроса (т е. после того как лифт достигнет заданного этажа) переменной присваивается значение 0.
до сих пор работа лифта описывалась с точки зрения пользователя,
но ситуация станет более интересной, если рассмотреть ее с точки зрения лифта.
лифт может находиться в одном из трех следующих состояний: движение вниз, движение вверх или нейтральное состояние
для человека текущее состояние обозначается светящимися стрелками внутри лифта
это его "базовый этаж", так как большинство людей входят в него именно здесь
если лифт находится на этаже 2 в состоянии neutral, двери со временем закроются и лифт будет {{ожидать следующей команды}}
