the notion of an algorithm is basic to all of computer programming, so we should begin with a careful analysis of this concept.
the word "algorithm" itself is quite interesting;
at first glance it may look as though someone intended to write "logarithm" but jumbled up the first four letters.
the word did not appear in webster's new world dictionary as late as 1957;
we find only the older form "algorism" with its ancient meaning, the process of doing arithmetic using arabic numerals.
during the middle ages, abacists computed on the abacus and algorists computed by algorism.
by the time of the renaissance, the origin of this word was in doubt,
early linguists attempted to guess at its derivation by making combinations like algiros [painful] + arithmos [number];
others said no, the word comes from "king algor of castile".
finally, historians of mathematics found the true origin of the word algorism: it comes from the name of a famous persian textbook author,
abu'abd allah muhammad ibn musa al-khwarizmt (c 825) - literally, "father of abdullah, mohammed, son of moses, native of khwarizm.
the aral sea in central asia was once known as lake khwarizm, and the khwarizm region is located in the amu river basin just south of that sea.
al-khwarizm wrote the celebrated book kitab aljabr wa'l-muqabala ("rules of restoring and equating");
another word, "algebra" stems from the title of his book, which was a systematic study of the solution of linear and quadratic equations.
[for notes on al-khwarizmlâ€™s life and work, see h zemanek, lecture notes in computer science 122 a981), 1-81].
gradually the form and meaning of algorism became corrupted; as explained by the oxford english dictionary, the word "passed through many pseudo-etymological perversions,
including a recent algorithm, in which it is learnedly confused" with the greek root of the word arithmetic.
this change from "algorism" to "algorithm" is not hard to understand in view of the fact that people had forgotten the original derivation of the word.
an early german mathematical dictionary, vollstk'ndiges mathematisches lexicon (leipzig: 1747), gave the following definition for the word algorithmus:
"under this designation are combined the notions of the four types of arithmetic calculations, namely addition, multiplication, subtraction, and division.
"the latin phrase algorithmus infinitesimalis was at that time used to denote "ways of calculation with infinitely small quantities", as invented by leibniz.
"by 1950, the word algorithm was most frequently associated with euclid's algorithm, a process for finding the {{greatest common divisor}} of two numbers
that appears in euclid's elements (book 7, propositions 1 and 2).
it will be instructive to exhibit euclid's algorithm here.
of course, euclid did not present his algorithm in just this manner.
the format above illustrates the style in which all of the algorithms throughout this book will be presented.
each algorithm we consider has been given an identifying letter (e in the preceding example),
and the steps of the algorithm are identified by this letter followed by a number (el, e2, e3).
the chapters are divided into numbered sections; within a section the algorithms are designated by letter only,
but when algorithms are referred to in other sections, the appropriate section number is attached.
for example, we are now in section 1.1; within this section euclid's algorithm is called algorithm e,
while in later sections it is referred to as algorithm 1:1e.
as an example of the use of {{doubly linked lists}}, we will now consider the writing of a discrete simulation program.
"discrete simulation" means the simulation of a system in which all changes in the state of the system may be assumed to happen at certain discrete instants of time.
the "system" being simulated is usually a set of individual activities that are largely independent although they interact with each other;
examples are customers at a store, ships in a harbor, people in a corporation.
in a discrete simulation, we proceed by doing whatever is to be done at a certain instant of simulated time,
then advance the simulated clock to the next time when some action is scheduled to occur.
By contrast, a "continuous simulation" would be simulation of activities that are under continuous changes,
such as traffic moving on a highway, spaceships traveling to other planets, etc.
{{Continuous simulation}} can often be satisfactorily {{approximated}} by discrete simulation with very small time intervals between steps; 
however, in such a case we usually have "synchronous" discrete simulation, in which many parts of the system are slightly altered at each discrete time interval
and such an application generally calls for a somewhat different type of program organization than the kind considered here.
the program developed below simulates the elevator system in the mathematics building of the california institute of technology.
the results of such a simulation will perhaps be of use only to people who make reasonably frequent visits to caltech;
and even for them, it may be simpler just to try using the elevator several times instead of writing a computer program.
but, as is usual with {{simulation studies}}, the methods we will use are of much more interest than the answers given by the program.
the methods to be discussed below illustrate typical implementation techniques used with {{discrete simulation}} programs.
the mathematics building has five floors: sub-basement, basement, first, second, and third.
there is a single elevator, which has automatic controls and can stop at each floor.
for convenience we will renumber the floors 0, 1, 2, 3, and 4.
on each floor there are two call buttons, one for up and one for down.
actually floor 0 has only up and floor 4 has only down,
but we may ignore that anomaly since the excess buttons will never be used
corresponding to these buttons, there are ten variables callup [j] and calldown [j], 0 <= j <= 4.
there are also variables callcar[j], 0 <= j <= 4, representing buttons within the elevator car, which direct it to a destination floor.
when a person presses a button, the appropriate variable is set to 1;
the elevator clears the variable to 0 after the request has been fulfilled.
so far we have described the elevator from a user's point of view;
the situation is more interesting as viewed by the elevator.
the elevator is in one of three states: goingup, goingdown, or neutral.
the current state is indicated to passengers by lighted arrows inside the elevator.
this is the "home floor," since most passengers get in there
on floor 2 in neutral state, the doors will eventually close and the machine {{will wait silently for another command}}.
